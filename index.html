<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Despicable Me Merge Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            background-image: linear-gradient(to bottom, #4a90e2, #6ac0ff);
            color: #333;
        }
        
        header {
            background-color: #ffde00;
            width: 100%;
            text-align: center;
            padding: 10px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }
        
        h1 {
            margin: 0;
            color: #4a4a4a;
        }
        
        .game-container {
            position: relative;
            width: 360px;
            height: 480px;
            background-color: #e0e0e0;
            border: 3px solid #333;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .game-board {
            width: 100%;
            height: 100%;
            position: relative;
            background-color: #f8f8f8;
        }
        
        .item {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            font-size: 32px; /* Size for emojis */
        }
        
        .item:hover {
            transform: scale(1.05);
        }
        
        .dragging {
            opacity: 0.8;
            z-index: 1000;
        }
        
        .item .level {
            position: absolute;
            bottom: -3px;
            right: -3px;
            background-color: #333;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            font-weight: bold;
        }
        
        .score-container {
            margin-top: 20px;
            background-color: #ffde00;
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        button {
            background-color: #ffde00;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }
        
        button:hover {
            transform: scale(1.05);
            background-color: #ffd000;
        }
        
        .new-item-btn {
            background-color: #4caf50;
            color: white;
        }
        
        .character-guide {
            margin-top: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 10px;
            max-width: 360px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        
        .guide-item {
            display: flex;
            align-items: center;
            font-size: 14px;
            background-color: #ffde00;
            padding: 5px 10px;
            border-radius: 15px;
        }
        
        .guide-item span {
            margin-left: 5px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Despicable Me Merge Game</h1>
    </header>
    
    <div class="game-container">
        <div class="game-board" id="gameBoard"></div>
    </div>
    
    <div class="score-container">
        <span>Score: </span><span id="score">0</span>
    </div>
    
    <div class="controls">
        <button class="new-item-btn" id="newItemBtn">Add Minion</button>
        <button id="resetBtn">Reset Game</button>
    </div>
    
    <div class="character-guide" id="characterGuide"></div>
    
    <script>
        const characters = [
            { name: "Stuart", emoji: "üëÅ", color: "#ffde00", level: 1 },
            { name: "Kevin", emoji: "üëì", color: "#ffde00", level: 2 },
            { name: "Bob", emoji: "üë∂", color: "#ffde00", level: 3 },
            { name: "Dave", emoji: "üçå", color: "#ffde00", level: 4 },
            { name: "Jerry", emoji: "üî¨", color: "#ffde00", level: 5 },
            { name: "Tim", emoji: "üß†", color: "#ffde00", level: 6 },
            { name: "Carl", emoji: "ü§ì", color: "#ffde00", level: 7 },
            { name: "Gru", emoji: "üß£", color: "#333333", level: 8 },
            { name: "Vector", emoji: "ü¶à", color: "#ff9800", level: 9 },
            { name: "Lucy", emoji: "üë©‚Äçü¶∞", color: "#e91e63", level: 10 },
            { name: "El Macho", emoji: "üí™", color: "#9c27b0", level: 11 },
        ];
        
        let score = 0;
        let draggingItem = null;
        let items = [];
        let nextItemId = 0;
        const gameBoard = document.getElementById('gameBoard');
        const scoreDisplay = document.getElementById('score');
        const newItemBtn = document.getElementById('newItemBtn');
        const resetBtn = document.getElementById('resetBtn');
        const characterGuide = document.getElementById('characterGuide');
        
        // Initialize the game
        function initGame() {
            // Add event listeners
            newItemBtn.addEventListener('click', addNewItem);
            resetBtn.addEventListener('click', resetGame);
            
            // Create character guide
            createCharacterGuide();
            
            // Add initial items
            for (let i = 0; i < 3; i++) {
                addNewItem();
            }
            
            updateScore(0);
        }
        
        // Create character guide display
        function createCharacterGuide() {
            characterGuide.innerHTML = '';
            characters.forEach(character => {
                const guideItem = document.createElement('div');
                guideItem.className = 'guide-item';
                guideItem.innerHTML = `${character.emoji} <span>Lv${character.level}: ${character.name}</span>`;
                characterGuide.appendChild(guideItem);
            });
        }
        
        // Create a new item element
        function createItemElement(character, x, y) {
            const item = document.createElement('div');
            item.className = 'item';
            item.id = `item-${nextItemId++}`;
            item.dataset.level = character.level;
            item.style.backgroundColor = character.color;
            item.style.left = `${x}px`;
            item.style.top = `${y}px`;
            item.title = `${character.name} (Level ${character.level})`;
            
            // Add emoji
            item.innerHTML = character.emoji;
            
            // Add level indicator
            const levelDiv = document.createElement('div');
            levelDiv.className = 'level';
            levelDiv.textContent = character.level;
            item.appendChild(levelDiv);
            
            // Add drag functionality
            item.addEventListener('mousedown', startDrag);
            item.addEventListener('touchstart', startDrag, { passive: false });
            
            return item;
        }
        
        // Add a new random level 1-3 item
        function addNewItem() {
            if (items.length >= 25) {
                alert("The board is full! Merge some items to make space.");
                return;
            }
            
            const level = Math.floor(Math.random() * 3) + 1; // Random level 1-3
            const character = characters.find(c => c.level === level);
            
            // Find an empty position
            let x, y;
            let foundPosition = false;
            
            // Try up to 50 times to find an empty position
            for (let attempt = 0; attempt < 50; attempt++) {
                x = Math.floor(Math.random() * (gameBoard.clientWidth - 60));
                y = Math.floor(Math.random() * (gameBoard.clientHeight - 60));
                
                // Check if position overlaps with existing items
                let overlaps = false;
                for (const existingItem of items) {
                    const existingRect = existingItem.getBoundingClientRect();
                    const boardRect = gameBoard.getBoundingClientRect();
                    const existingX = existingRect.left - boardRect.left;
                    const existingY = existingRect.top - boardRect.top;
                    
                    const distance = Math.sqrt(
                        Math.pow(x - existingX, 2) + Math.pow(y - existingY, 2)
                    );
                    
                    if (distance < 60) {
                        overlaps = true;
                        break;
                    }
                }
                
                if (!overlaps) {
                    foundPosition = true;
                    break;
                }
            }
            
            if (!foundPosition) {
                // If we couldn't find a position, just place it somewhere
                x = Math.floor(Math.random() * (gameBoard.clientWidth - 60));
                y = Math.floor(Math.random() * (gameBoard.clientHeight - 60));
            }
            
            const newItem = createItemElement(character, x, y);
            gameBoard.appendChild(newItem);
            items.push(newItem);
        }
        
        // Handle drag start
        function startDrag(e) {
            e.preventDefault();
            
            draggingItem = this;
            draggingItem.classList.add('dragging');
            
            // Record the initial position of the mouse/touch relative to the item
            const rect = draggingItem.getBoundingClientRect();
            const boardRect = gameBoard.getBoundingClientRect();
            
            let clientX, clientY;
            
            if (e.type === 'mousedown') {
                clientX = e.clientX;
                clientY = e.clientY;
            } else if (e.type === 'touchstart') {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }
            
            const offsetX = clientX - rect.left;
            const offsetY = clientY - rect.top;
            
            // Add move and end event listeners
            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
            
            // Drag function
            function drag(e) {
                e.preventDefault();
                
                let clientX, clientY;
                
                if (e.type === 'mousemove') {
                    clientX = e.clientX;
                    clientY = e.clientY;
                } else if (e.type === 'touchmove') {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                }
                
                // Calculate new position
                let newLeft = clientX - offsetX - boardRect.left;
                let newTop = clientY - offsetY - boardRect.top;
                
                // Constrain to game board
                newLeft = Math.max(0, Math.min(newLeft, gameBoard.clientWidth - rect.width));
                newTop = Math.max(0, Math.min(newTop, gameBoard.clientHeight - rect.height));
                
                // Update position
                draggingItem.style.left = `${newLeft}px`;
                draggingItem.style.top = `${newTop}px`;
            }
            
            // End drag function
            function endDrag() {
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchend', endDrag);
                
                draggingItem.classList.remove('dragging');
                
                // Check for collisions with other items
                checkCollisions(draggingItem);
                
                draggingItem = null;
            }
        }
        
        // Check if items can be merged
        function checkCollisions(item) {
            const rect1 = item.getBoundingClientRect();
            const boardRect = gameBoard.getBoundingClientRect();
            const level = parseInt(item.dataset.level);
            
            for (const otherItem of items) {
                if (otherItem === item) continue;
                
                const otherLevel = parseInt(otherItem.dataset.level);
                
                // Only merge items of the same level
                if (level !== otherLevel) continue;
                
                const rect2 = otherItem.getBoundingClientRect();
                
                // Check for collision
                const xOverlap = (rect1.left <= rect2.right) && (rect1.right >= rect2.left);
                const yOverlap = (rect1.top <= rect2.bottom) && (rect1.bottom >= rect2.top);
                
                if (xOverlap && yOverlap) {
                    // Items have collided, merge them
                    mergeItems(item, otherItem);
                    return;
                }
            }
        }
        
        // Merge two items to create a higher level item
        function mergeItems(item1, item2) {
            const level = parseInt(item1.dataset.level);
            
            // Don't merge if already at max level
            if (level >= characters.length) {
                return;
            }
            
            // Calculate new position (average of the two items)
            const rect1 = item1.getBoundingClientRect();
            const rect2 = item2.getBoundingClientRect();
            const boardRect = gameBoard.getBoundingClientRect();
            
            const x1 = rect1.left - boardRect.left + rect1.width / 2;
            const y1 = rect1.top - boardRect.top + rect1.height / 2;
            const x2 = rect2.left - boardRect.left + rect2.width / 2;
            const y2 = rect2.top - boardRect.top + rect2.height / 2;
            
            const newX = (x1 + x2) / 2 - 30; // 30 is half of item width
            const newY = (y1 + y2) / 2 - 30; // 30 is half of item height
            
            // Create new merged item
            const newLevel = level + 1;
            const newCharacter = characters.find(c => c.level === newLevel);
            const newItem = createItemElement(newCharacter, newX, newY);
            
            // Remove old items
            gameBoard.removeChild(item1);
            gameBoard.removeChild(item2);
            
            items = items.filter(item => item !== item1 && item !== item2);
            
            // Add new item
            gameBoard.appendChild(newItem);
            items.push(newItem);
            
            // Update score
            updateScore(score + newLevel * 10);
            
            // Special animation for merge
            newItem.style.transform = 'scale(1.2)';
            setTimeout(() => {
                newItem.style.transform = 'scale(1)';
            }, 300);
            
            // If reached the max level, show victory
            if (newLevel === characters.length) {
                setTimeout(() => {
                    alert(`Congratulations! You've merged all the way to ${newCharacter.name}! Final score: ${score}`);
                }, 500);
            }
        }
        
        // Update the score display
        function updateScore(newScore) {
            score = newScore;
            scoreDisplay.textContent = score;
        }
        
        // Reset the game
        function resetGame() {
            // Clear all items
            while (gameBoard.firstChild) {
                gameBoard.removeChild(gameBoard.firstChild);
            }
            
            items = [];
            nextItemId = 0;
            
            // Reset score
            updateScore(0);
            
            // Add initial items
            for (let i = 0; i < 3; i++) {
                addNewItem();
            }
        }
        
        // Initialize the game when the page loads
        window.onload = initGame;
    </script>
</body>
</html>

